'''
pdb2.py
by Lane Votapka
Amaro Lab 2015

This file contains multiple functions and classes that can be used to read and write PDB, PQR, and PQRXML formats in versatile ways.
It also contains some functions for processing loaded structures, such as center-of-mass calculations, etc.

'''
import re, warnings, time, os, sys
from copy import deepcopy
import string
import numpy
from numpy import array, matrix
from cStringIO import StringIO # NOTE: may want to change this to cStringIO if more speed is needed in the future
#from modscience import normalize_vector # makes the longest vector equal to 1 # this is too annoying to import
import unittest
import xml.etree.cElementTree as ET
from xml.etree.cElementTree import iterparse # for parsing the XML
from cStringIO import StringIO # allows files to be loaded as a special object

REMARK = 'REMARK   1 File generated by pdb2.py by Lane Votapka\n'
atomic_weights = {'H':1.00800, 'C':12.0110, 'N':14.00699, 'O':15.9994, 'F':18.9984, 'Na':22.9898, 'Mg':24.305, 'P':30.9738, 'S':32.065, 'Cl':35.453, 'K':39.0983, 'Ca':40.078, 'Fe':55.845, 'Br':79.904, 'I':126.9045, '':0.0, ' ':0.0, 'G':0.0} # all the atomic weights. NOTE: 'G' refers to a "ghost" atom
radii = {'C': 1.9080, 'N':1.824, 'H':0.0000, 'O':1.66, 'S':2.000, 'Ca':1.97, 'P':2.00, 'Cu':2.5, 'Zn':2.5, '':0.0, "G":0.0}
TER_atoms = ['OXT', 'Ca+'] # atom names after which automatically add a TER card if amber mode activated
TER_cutoff = sys.maxint # the distance at which to assume atoms aren't bonded, and add a TER card
TER_resnames = ["WAT", "K+", "Cl-", "Na+"] # resnames which represent an entire molecule of their own
water_resnames = ('TIP','H2O','HOH','WAT')

class Atom():
  def __init__(self, record, index, name, altloc, resname, chain, resid, icode, x, y, z, occupancy, beta, element, charge, rawline='', radius='0.0'):
    # fill out atomic information
    self.record = record
    self.index = int(index)
    self.name = name.strip()
    self.altloc = altloc
    self.resname = resname.strip()
    self.chain = chain
    self.resid = resid
    self.icode = icode
    self.coords = [float(x), float(y), float(z)]
    self.x = float(x)
    self.y = float(y)
    self.z = float(z)
    self.occupancy = float(occupancy)
    self.beta = float(beta)
    self.element = element
    if not self.element or self.element == ' ': # then assign an element to this molecule
      self.element = find_element(self.name)
    if charge:
      try:
        self.charge = float(charge)
      except ValueError: # then there is something weird with this value, and was obviously not meant to be a charge
        self.charge = charge
    else:
      self.charge = charge
    if radius:
      self.radius = float(radius)
    else:
      self.radius = radius
    #self.rawline = rawline
  def get_coords(self):
    return self.coords

  def to_dict(self):
    ''' returns the attributes of the Atom() class in dictionary form'''
    our_dict = {}
    for var in ['record','index','name','altloc','resname','chain','resid','icode','occupancy','beta','element','charge','radius']:
      exec "our_dict['%s'] = self.%s" % (var,var)
    our_dict['x'] = self.coords[0]; our_dict['y'] = self.coords[1]; our_dict['z'] = self.coords[2]
    return our_dict # return the dictionary

  def set_coords(self, coord):
    if type(coord) == matrix or type(coord) == array:
      coord = coord[0,0:3].tolist()[0]
    self.coords = coord
    return

  def print_pdbline(self, standard=True, space_separated_values=False):
    name = self.name
    if len(name) <= 3: name = ''.join((' ',name)) # then pad it to left with a space
    if standard:
      #formatline = "{0:<6.6}{1:>5.5} {2:<4.4}{3:1.1}{4:3.3} {5:1.1}{6:>4.4}{7:1.1}   {8:> 8.3f}{9:> 8.3f}{10:> 8.3f}{11:>6.2f}{12:>6.2f}          {13:>2.2}{14:>2.2}\n" # charge was included here, but insufficient space
      #return formatline.format(self.record,str(self.index),name,self.altloc,self.resname,self.chain,self.resid,self.icode,self.coords[0],self.coords[1],self.coords[2],self.occupancy,self.beta,self.element,self.charge)
      formatline = "{0:<6.6}{1:>5.5} {2:<4.4}{3:1.1}{4:3.3} {5:1.1}{6:>4.4}{7:1.1}   {8:> 8.3f}{9:> 8.3f}{10:> 8.3f}{11:>6.2f}{12:>6.2f}          {13:>2.2}  \n"
      return formatline.format(self.record,str(self.index),name,self.altloc,self.resname,self.chain,self.resid,self.icode,self.coords[0],self.coords[1],self.coords[2],self.occupancy,self.beta,self.element,self.charge)
    elif space_separated_values: # then every value is only separated by a space
      #formatline = "{0} {1} {2} {3} {4} {5} {6} {7} {8:.3} {9:.3} {10:.3} {11:.2} {12:.2} {13} {14}" # charge was included here, but not included for standard mode, so I'm not including here either
      #return formatline.format(self.record,str(self.index),self.name,self.altloc,self.resname,self.chain,self.resid,self.icode,self.coords[0],self.coords[1],self.coords[2],self.occupancy,self.beta,self.element,self.charge)
      formatline = "{0} {1} {2} {3} {4} {5} {6} {7} {8:.3f} {9:.3f} {10:.3f} {11:.2f} {12:.2f} {13}"
      ourline = formatline.format(self.record,str(self.index),self.name,self.altloc,self.resname,self.chain,self.resid,self.icode,self.coords[0],self.coords[1],self.coords[2],self.occupancy,self.beta,self.element)
      ourline = ' '.join(ourline.split()) # remove extra spaces
      return ourline
    else: # then print out a line that is close to standard at least for small PDBs, but can handle many more atoms/residues
      self.record = "ATOM" # set it to atom by default, which gives us more room that HETATM
      record_index_spaces = len(self.record) + len(str(self.index)) # all this gibberish just to get some decent spacing for the index
      after_index_spaces = 1
      if record_index_spaces < 1:
        after_index_spaces = 0
        record_index_spaces = 1
      record_index_formatline = r"{0:}{1:}{2:}{3:}".format(self.record, ' '*(11-record_index_spaces), str(self.index), ' '*after_index_spaces)
      after_resid_spaces = 4 # all this gibberish to get decent spacing for the resid column
      before_resid_spaces = 4 - len(str(self.resid))
      if before_resid_spaces < 0:
        after_resid_spaces = after_resid_spaces + before_resid_spaces
        before_resid_spaces = 0
      if after_resid_spaces < 0: # then its a HUGE resid number
        after_resid_spaces = 0 # forget about formatting
      resid_formatline = r"{0:}{1:}{2:}".format(' '*before_resid_spaces, self.resid, ' '*after_resid_spaces)
      #formatline = "{0}{1:<4.4}{2:1.1}{3:3.3} {4:1.1}{5}{6:> 8.3f}{7:> 8.3f}{8:> 8.3f}{9:>6.2f}{10:>6.2f}          {11:>2.2}{12:>2.2}\n"
      beta = '{0:4.2f}'.format(self.beta)[:4]
      occupancy = '{0:4.2f}'.format(self.occupancy)[:4]
      formatline = "{0}{1:<4.4}{2:1.1}{3:3.3} {4:1.1}{5}{6:> 8.3f}{7:> 8.3f}{8:> 8.3f}  {9}  {10}          {11:>2.2}{12:>2.2}\n"
      return formatline.format(record_index_formatline,name,self.altloc,self.resname,self.chain,resid_formatline,self.coords[0],self.coords[1],self.coords[2],occupancy,beta,self.element,self.charge)

  def set_occupancy(self,occupancy):
    self.occupancy = occupancy

class Structure():
  def __init__(self, struct_id):
    self.struct_id = struct_id
    self.atoms = []
    self.num_atoms = 0
    self.num_resids = 0
    return

  def get_atoms(self):
    return self.atoms

  def save(self, filename, amber=False, standard=True, space_separated_values=False, remark=True, endmdl=True, pqr=False, pqrxml=False, nohydrogens=False):
    '''Save this structure as a PDB or PQR file'''
    # perform some checks
    if standard:
      if self.num_atoms > 99999: # then it will require 6 spaces
        raise Exception, "PDB file too big to write in standardized format. Atom indeces exceed 5 digit maximum. Set 'standard' option to False to enable large pdb file writing"
      if self.num_resids > 9999: # then it will require 5 spaces
        raise Exception, "Too many residues to write in standardized format. Residue indeces exceed 4 digit maximum. Set 'standard' option to False to enable large pdb file writing"

    # write the file
    outfile = open(filename, 'w')
    if remark==True and pqrxml==False: # because we don't want remarks added to pqrxml files
      outfile.write(REMARK)
    if self.num_atoms > 0: oldcoord = self.atoms[0].coords
    #if self.num_resids > 9999: # then convert to hex
    #  self.resid_to_hex()
    if self.num_atoms > 0: oldresid = self.atoms[0].resid
    if pqrxml==True: outfile.write("<roottag>\n  <residue>\n    <residue_name>%s</residue_name>\n    <residue_number>%s</residue_number>\n" % (self.atoms[0].resname, self.atoms[0].resid))
    for atom in self.atoms: # for every atom in this structure
      if amber: # for TER cards before an atom
        if (atom.resname in TER_resnames and atom.resid != oldresid):
          outfile.write("TER\n")
      if pqr==True:
        outfile.write(make_pqr_line(atom.to_dict())) # join an endline to the end of the pqr line
      elif pqrxml==True:
        if oldresid != atom.resid:
          outfile.write("  </residue>\n  <residue>\n    <residue_name>%s</residue_name>\n    <residue_number>%s</residue_number>\n" % (atom.resname, atom.resid))
        outfile.write(make_pqrxml_line(atom.to_dict()))

      else: # then write a pdb file
        outfile.write(atom.print_pdbline(standard=standard, space_separated_values=space_separated_values))
      if amber: # need to correctly place the TER cards after the current atom
        coord_dist = array(atom.coords) - array(oldcoord)
        if atom.name in TER_atoms or numpy.linalg.norm(coord_dist) > TER_cutoff : # print a TER card
          outfile.write("TER\n")
      oldcoord = atom.coords
      oldresid = atom.resid
      #print atom.print_pdbline()
    if pqrxml: outfile.write("  </residue>\n</roottag>\n")
    if endmdl and not pqrxml:
      outfile.write('ENDMDL\n')
    outfile.close()

  def moveby(self, vector):
    '''move all atoms by the vector'''
    vector = numpy.array(vector)
    #print vector
    for atom in self.atoms:
      atom.coords = list(vector + numpy.array(atom.coords))

  '''def remove_atoms(self, indeces):
    'remove all atoms with given index from the structure. indeces may be a list'
    pass'''

  def matrix_operation(self,op_matrix):
    '''given a matrix, will apply matrix*vector operation on every atom'''
    for atom in self.atoms:
      coords = numpy.hstack((matrix([atom.coords]),matrix([[1.0]])))
      newcoord = op_matrix * coords.T
      atom.coords = newcoord.T.tolist()[0][:3]


  def remove_res(self, resid):
    '''remove all atoms with given resid from the structure. resid may be a list'''
    resids = set(resid) # convert to a set if not already
    index_counter = 0
    found_resids = set() # just to keep track of all the resids given that are ACTUALLY in this pdb

    while index_counter < self.num_atoms: # for all atoms
      if self.atoms[index_counter].resid in resids:
        self.atoms.pop(index_counter)
        self.num_atoms -= 1
        if self.num_atoms == 0: break
        found_resids.add(self.atoms[index_counter].resid)
        #resids.remove(self.atoms[index_counter].resid)
      else:
        self.atoms[index_counter].index = index_counter+1 # set the internal index numbers to be incremental
        index_counter += 1 # increment the index counter

    self.num_resids -= len(found_resids) # reset the number of residues

  def renumber_indeces(self, start_at = 1):
    '''renumbers the indeces within the pdb so that they are consecutively numbered'''
    counter = start_at
    for atom in self.atoms:
      atom.index = counter
      counter += 1
    return

  def resid_to_hex(self):
    '''converts all resids to hexadecimal values '''
    for atom in self.atoms:
      resid = int(atom.resid)
      hex_str = hex(resid)
      newresid = "%4s" % hex_str[2:]
      atom.resid = newresid

# this regular expression should satisfy the fields of nearly any pdb file
#pdbregex = re.compile(r'([A-Z]+) *([0-9]+) *([\S]+) +([\S]{3}) *([A-Z]{0,1}) *([0-9]+) *([-]{0,1}[0-9\.]+) *([- ][0-9\.]+) *([- ][0-9\.]+) *([- ][0-9\.]+) *([- ][0-9\.]+) *(.)?$') # the original PDB parser regex
pdbregex = re.compile(r'^([A-Z]+) *([0-9a-f\*]+) *([\S]{1,4}) *([ a-zA-Z]{1})([\S]{3,4}| [\S]{2}|  [\S]) +([@A-Z]{0,1}) *([-0-9a-f]+)([a-zA-Z]{0,1}) *([- ]{0,1}[0-9]+\.[0-9]{3}) *([- ]{0,1}[0-9]+\.[0-9]{3}) *([- ]{0,1}[0-9]+\.[0-9]{3}) *([- ]{0,1}[0-9]+\.[0-9]{2}) *([- ]{0,1}[0-9]+\.[0-9]{2}) *(\S{0,2}) *(\S{0,2}) *$')
    #pdbregex = re.compile(r'([A-Z]+) *([0-9a-f\*]+) *([\S]{1,4}) *([ a-zA-Z]{1})([\S]{3}| [\S]{2}|  [\S]) +([A-Z]{0,1}) *([-0-9]+)([a-zA-Z]{0,1}) *([- ][0-9\.]+) *([- ][0-9\.]+) *([- ][0-9\.]+) *([- ][0-9]+\.[0-9]{2}) *([- ]{0,1}[\.0-9]+) *(\S{0,2}) *(\S{0,2}) *$')
    #pdbregex = re.compile(r'([A-Z]+) *([0-9]+) *([\S]+) *([a-zA-Z]{0,1}) *([\S]{3}) *([A-Z]{0,1}) *([0-9]+)([a-zA-Z]{0,1}) *([- ][0-9\.]+) *([- ][0-9\.]+) *([- ][0-9\.]+) *([- ][0-9\.]+) *([- ][0-9\.]+) *(\S{0,2}) *(\S{0,2}) *$')
pqrregex = re.compile(r'^([A-Z]+) *([0-9a-f\*]+) *([\S]{1,4}) *([\S]{3,4}| [\S]{2}|  [\S]) +([@A-Z]{0,1}) *([-0-9a-f]+)([a-zA-Z]{0,1}) *([- ]{0,1}[0-9]+\.[0-9]{3}) *([- ]{0,1}[0-9]+\.[0-9]{3}) *([- ]{0,1}[0-9]+\.[0-9]{3}) *([- ]{0,1}[0-9]+\.[0-9]{1,4}) *([- ]{0,1}[0-9]+\.[0-9]{1,4}) *$')

class Big_PDBParser():
  def pdbparse(self, filename, preserve_index = False, preserve_resid = True, pqr=False, conventional=False):
    '''parses a PDB file and returns the line as a dict.
    Atom indeces automatically numbered. If preserve_index
    is set to True, then indeces from the file will be preserved'''

    atoms = []
    if type(filename) == file or type(filename) == type(StringIO()): # then we're passing a file or file-like object
      pdbfile = filename
    elif type(filename) == str: # otherwise, try to open it as a string
      pdbfile = open(filename, 'r')
    counter = 1 # count each line of the file
    residcounter = 0
    oldresid = 0
    for pdbline in pdbfile:
      if not pdbline.startswith('ATOM') and not pdbline.startswith('HETATM'):
        continue
      pdbline = pdbline.strip()
      if pqr: # then we are dealing with a pqr file
        if conventional:
          rawlinelist = self.conventional_parse(pdbline, pqr=True)
        else:
          rawlinelist = re.findall(pqrregex, pdbline)
        #assert conventional==False, "conventional parsing for PQRs not yet implemented."

        if not rawlinelist:
          linelist = pdbline.split() # then simply split on whitespace
          if len(linelist) == 9: # then the chain is missing
            linelist.insert(3,' ')
          linelist.insert(2,'')
          linelist.insert(6,'')



        try:
          linelist = rawlinelist[0]
          if len(linelist) == 10:
            linelist.insert(5,'')
          if len(linelist) == 11: # then the chain is missing
            linelist.insert(4,' ')

          if oldresid == "": oldresid = linelist[5]
          if linelist[5] != oldresid: # increment the resid counter
            residcounter += 1
            oldresid = linelist[5]

          if preserve_index:
            atomindex = linelist[1]
          else:
            atomindex = counter

          if preserve_resid:
            resid_index = linelist[5]
          else:
            resid_index = str(residcounter)

          #print "linelist:", linelist
          #exit()

          element=linelist[2][0]
          atom = Atom(record=linelist[0], index=atomindex, name=linelist[2], altloc="", resname=linelist[3], chain=linelist[4], resid=resid_index, icode=linelist[6], x=linelist[7], y=linelist[8], z=linelist[9], charge=linelist[10], radius=linelist[11], occupancy='1.0', beta='0.0', element=element)

        except IndexError:
          print "failure line: %s" % pdbline
          print "rawline: %s" % rawlinelist
          raise IndexError



      else: # then parse for a pdb file
        if conventional: # then we are parsing using conventional
          rawlinelist = self.conventional_parse(pdbline)
        else:
          rawlinelist = re.findall(pdbregex, pdbline)
          # fill the atom object
          if not rawlinelist:
            #print "error parsing line:\n", pdbline, rawlinelist
            #print "attempting to parse conventionally..."
            rawlinelist = self.conventional_parse(pdbline)
            rawlinelist[0][13] = rawlinelist[0][2][0] # getting the first letter to be the element
            #print "ALERT: conventional parsing not yet implemented!" # NOTE: line marked for removal upon completion of conventional parsing
            #continue
        try:
          linelist = rawlinelist[0]
          if oldresid == "": oldresid = linelist[6]
          if linelist[6] != oldresid: # increment the resid counter
            residcounter += 1
            oldresid = linelist[6]
          #print "linelist: ", linelist
          if preserve_index:
            atomindex = linelist[1]
          else:
            atomindex = counter
          if preserve_resid:
            resid_index = linelist[6]
          else:
            resid_index = str(residcounter)


          #if charge and not element: # then probabily it assigned the charge when it should have assigned the element
            #if re.match(): # then there are alphabetical characters in the charge when there should be numbers for charge UNFINISHED...

          atom = Atom(record=linelist[0], index=atomindex, name=linelist[2], altloc=linelist[3], resname=linelist[4], chain=linelist[5], resid=resid_index, icode=linelist[7], x=linelist[8], y=linelist[9], z=linelist[10], occupancy=linelist[11], beta=linelist[12], element=linelist[13], charge=linelist[14]) #, rawline=pdbline)


        except IndexError:
          print "failure line: %s" % pdbline
          print "rawline: %s" % rawlinelist
          raise IndexError

        #atom = Atom(record=linelist[0], index=linelist[1], name=linelist[2], resname=linelist[3], chain=linelist[4], resid=linelist[5], x=linelist[6], y=linelist[7], z=linelist[8], occupancy=linelist[9], beta=linelist[10], atomtype=linelist[11])


      atoms.append(atom)
      #print linelist
      counter += 1
      if type(filename) == str: pdbfile = open(filename, 'r')
    return atoms, residcounter
    #if pdbline.startswith != "ATOM" and pdbline

  def conventional_parse(self,line, pqr=False): # an emergency function that attempts to parse the line of a pdb file according to conventional rules
    if pqr:
      conv_regex = re.compile(r'^(.{6})(.{5}).(.{4})(.{5}).(.{4})    (.{8})(.{8})(.{8})(.{8})(.{7})*$') # untested...
    else:
      conv_regex = re.compile(r'^(.{6})(.{5}).(.{4})(.)(.{4})(.)(.{4})(.).{3}(.{8})(.{8})(.{8})(.{6})(.{6}).{0,10}(.{0,2})(.{0,2}) *$')
    rawlinelist = re.findall(conv_regex,line)

    #print "rawlinelist:", map(string.strip, rawlinelist[0])
    if not rawlinelist:
      print "problem with line:", line
    return [map(string.strip, rawlinelist[0])] # strip all the spaces off and return it

  def get_structure(self, struct_id, filename, preserve_index=False, preserve_resid=True, pqr=False, pqrxml=False, conventional=False):
    structure = Structure(struct_id)
    #structure.struct_id = struct_id
    # now parse the pdb file
    assert not (pqr == True and pqrxml == True), "both the 'pqr' and 'pqrxml' options may not be set to 'True' at the same time."
    if pqrxml:
      pqrxml_generator = pqr_xml_parse(filename, preserve_resid=preserve_resid, preserve_index=preserve_index)
      for atom_dict,num_res in pqrxml_generator:
        #print "atom_dict:", atom_dict
        atom = Atom(record="ATOM", index=atom_dict['index'], name=atom_dict['name'], altloc='', resname=atom_dict['resname'], chain='', resid=atom_dict['resid'], icode='', x=atom_dict['x'], y=atom_dict['y'], z=atom_dict['z'], element=atom_dict['name'][0], charge=atom_dict['charge'], radius=atom_dict['radius'], occupancy='1.0', beta='0.0', )
        structure.atoms.append(atom)
      structure.num_resids = num_res
    else:
      structure.atoms, structure.num_resids = self.pdbparse(filename,preserve_index,preserve_resid,pqr=pqr,conventional=conventional)
    structure.num_atoms = len(structure.atoms)
    #NOTE: There is no way so far to assign structure.num_resids
    return structure

parser=Big_PDBParser()

def pqr_xml_parse(filename, preserve_resid = True, preserve_index=False): #parses a pqrxml file from BrownDye
  # I have to code this carefully because I want it to be able to handle very large structures
  resid_counter = 1
  index_counter = 1

  context = iterparse(filename, events=("start", "end")) # get an iterable
  context = iter(context) # turn it into an iterator
  event, root = context.next()
  for event, elem in iterparse(filename):
    if event == "end":
      # residue info
      if elem.tag == "residue_name": resname = elem.text
      if preserve_resid and elem.tag == "residue_number": resid = int(elem.text)
      # atom info
      if elem.tag == "atom_name": atom_name = elem.text
      if preserve_index and elem.tag == "atom_number": index = int(elem.text)
      if elem.tag == "x": x = float(elem.text)
      if elem.tag == "y": y = float(elem.text)
      if elem.tag == "z": z = float(elem.text)
      if elem.tag == "charge": charge = float(elem.text)
      if elem.tag == "radius": radius = float(elem.text)
      if elem.tag == "atom": # ending the atom
        if not preserve_index:
          index = index_counter
        index_counter += 1
        line_dict = {'index':index, 'name':atom_name, 'resname':resname, 'resid':resid, 'x':x,'y':y,'z':z, 'charge':charge, 'radius':radius,}
        #print make_pqr_line(line_dict)
        yield line_dict, resid_counter
        elem.clear
      if elem.tag == "residue": # ending the residue
        if not preserve_resid:
          resid = resid_counter
        resid_counter += 1
        elem.clear()
        root.clear() # clear all previous entries in the root to save space

    elem.clear()
  '''
  root = tree.getroot()
  for residue in root:
    resname = residue.find('residue_name')
    resid = residue.find('residue_number')
    atoms = residue.findall('atom')
    for atom in atoms:
      atom_name = atom.find('atom_name')
      serial = atom.find('atom_number')
      x = atom.find('x')
      y = atom.find('y')
      z = atom.find('z')
      charge = atom.find('charge')
      radius = atom.find('radius')
      '''

def loadpdb(filename):
  "quick and convenient way to load a pdb file"
  newpdb=parser.get_structure('quickload', filename, preserve_resid=False )
  return newpdb

def loadpqr(filename,preserve_resid=False):
  "quick and convenient way to load a pqr file"
  newpqr=parser.get_structure('quickload', filename, pqr=True, preserve_resid=preserve_resid )
  return newpqr

def isfloat(number):
  if type(number) in [float, numpy.float64, numpy.float32]:
    return True
  else:
    return False

def make_pqr_line(user_line_dict, chain=False):
  '''creates a pqr line based on the specified parameters in line_dict'''
  line_dict = {'record':'ATOM', 'index':'0', 'name':'---', 'altloc':'', 'resname':'---', 'chain':'', 'resid':'0', 'icode':'', 'x':'0.000','y':'0.000','z':'0.000', 'charge':'0.0000', 'radius':'0.0000',}
  line_dict.update(user_line_dict)
  if isfloat(line_dict['x']): line_dict['x'] = "% 8.3f" % line_dict['x'] # if the value is a float, then convert to a string with the proper precision and width
  if isfloat(line_dict['y']): line_dict['y'] = "% 8.3f" % line_dict['y'] # if the value is a float, then convert to a string with the proper precision and width
  if isfloat(line_dict['z']): line_dict['z'] = "% 8.3f" % line_dict['z'] # if the value is a float, then convert to a string with the proper precision and width
  if isfloat(line_dict['charge']): line_dict['charge'] = "%0 6.4f" % line_dict['charge']
  if isfloat(line_dict['radius']): line_dict['radius'] = "%0 6.4f" % line_dict['radius']
  for key in line_dict.keys():
    line_dict[key] = str(line_dict[key]) # convert every value in the dictionary into a string for easy formatting
  if chain: # then write the chainID
    formatline = "{record:<6.6}{index:>5.10} {name:^4.4} {resname:<4.4}{chain:1.1}{resid:>4.9}    {x:>8.8}{y:>8.8}{z:>8.8} {charge:>7.7} {radius:>6.6}\n"
  else:
    formatline = "{record:<6.6}{index:>5.10} {name:^4.4} {resname:<4.4} {resid:>4.9}    {x:>8.8}{y:>8.8}{z:>8.8} {charge:>7.7} {radius:>6.6}\n"
  formatstring = formatline.format(**line_dict) # automatically populates the line with values from line_dict
  return formatstring

  #return formatline.format(self.record,str(self.index),name,self.altloc,self.resname,self.chain,self.resid,self.icode,self.coords[0],self.coords[1],self.coords[2],self.occupancy,self.beta,self.element,self.charge)



def make_pqrxml_line(user_line_dict):
  '''creates a pqr line based on the specified parameters in line_dict'''
  line_dict = {'record':'ATOM', 'index':'0', 'name':'---', 'altloc':'', 'resname':'---', 'chain':'', 'resid':'0', 'icode':'', 'x':'0.000','y':'0.000','z':'0.000', 'charge':'0.0000', 'radius':'0.0000',}
  line_dict.update(user_line_dict)
  if isfloat(line_dict['x']): line_dict['x'] = "%.6f" % line_dict['x'] # if the value is a float, then convert to a string with the proper precision and width
  if isfloat(line_dict['y']): line_dict['y'] = "%.6f" % line_dict['y'] # if the value is a float, then convert to a string with the proper precision and width
  if isfloat(line_dict['z']): line_dict['z'] = "%.6f" % line_dict['z'] # if the value is a float, then convert to a string with the proper precision and width
  if isfloat(line_dict['charge']): line_dict['charge'] = "%.6f" % line_dict['charge']
  if isfloat(line_dict['radius']): line_dict['radius'] = "%.6f" % line_dict['radius']
  for key in line_dict.keys():
    line_dict[key] = str(line_dict[key]) # convert every value in the dictionary into a string for easy formatting

  #formatline = "{record:<6.6}{index:>5.5} {name:^4.4}{altloc:1.1}{resname:3.3} {chain:1.1}{resid:>4.4}{icode:1.1}   {x:>8.8}{y:>8.8}{z:>8.8} {charge:>7.7}{radius:>7.7}\n"
  formatline = '''    <atom>
      <atom_name>{name}</atom_name>
      <atom_number>{index}</atom_number>
      <x>{x}</x>
      <y>{y}</y>
      <z>{z}</z>
      <charge>{charge}</charge>
      <radius>{radius}</radius>
    </atom>\n'''
  formatstring = formatline.format(**line_dict) # automatically populates the line with values from line_dict
  return formatstring

def find_element(name):
  '''find the most likely element of an atom given the atomic name'''
  letters = re.sub("[^a-zA-Z]*", "", name) # keeps only the letters in the 'name' string
  if letters in atomic_weights.keys(): # then we should have a weight for this entry
    return letters
  elif letters[0] in atomic_weights.keys(): # then its a named atom and we can take the first letter, which should be the proper name
    return letters[0]
  else:
    return ''


def avg(numlist):
  'finds the average of a list of numbers'
  oursum = sum(numlist)
  return oursum / float(len(numlist))

def getcoords(structure):
  'returns a list of coordinates from all of the atoms'
  coords = []
  atomlist = structure.get_atoms()
  for atom in atomlist:
    coords.append(atom.get_coords())
  return coords

def minmax_width (structure, water_only=True, wat_resnames=water_resnames):
  '''returns the width of the minimum and maximum coordinate values in the x,y,z direction'''
  coords = getcoords(structure)
  xlist = []
  ylist = []
  zlist = []
  i=0
  for coord in coords:
    if water_only and wat_resnames and structure.atoms[i].resname not in wat_resnames:
      i+=1
      continue
    xlist.append(coord[0])
    ylist.append(coord[1])
    zlist.append(coord[2])
    i+=1

  return ( max(xlist)-min(xlist), max(ylist)-min(ylist), max(zlist)-min(zlist))

def center (structure):
  '''returns the center of a pdb'''
  coords = getcoords(structure)
  xlist = []
  ylist = []
  zlist = []

  for coord in coords:
    xlist.append(coord[0])
    ylist.append(coord[1])
    zlist.append(coord[2])

  return ((max(xlist) + min(xlist))*0.5, (max(ylist) + min(ylist))*0.5, (max(zlist) + min(zlist)) * 0.5)

def center_of_mass (structure, weighted=True, heavy_atoms=False):
  '''finds the center of mass of a structure. Returns a numpy vector'''
  total_weight = 0.0 # keeps track of the weight of the molecule
  coord_sum = numpy.array([0.0,0.0,0.0]) # keeps track of the sum of the coordinates
  for atom in structure.get_atoms(): # for every atom in the structure
    if heavy_atoms==True and atom.element=='H': continue # we don't care about the hydrogens, so skip them
    if weighted:
      atom_weight = atomic_weights[atom.element]
    else:
      atom_weight = 1.0 # they are all given the same weight
    #print atom_weight
    total_weight += atom_weight # increment the total_weight
    coord = numpy.array(atom.get_coords())
    weighted_coord = coord * atom_weight
    coord_sum += weighted_coord # add the weighted coordinate
  #print total_weight
  return coord_sum / total_weight # divide by the total weight

def moments_of_inertia(structure, weighted=True):
  '''finds the inertia tensor for all atoms in the structure. Returns as a 3x3 numpy array'''
  com=center_of_mass(structure,weighted)
  #translate to the origin
  structure.moveby(-com)
  # these are the elements of our tensor
  Ixx = 0.0; Ixy = 0.0; Ixz = 0.0; Iyy = 0.0; Iyz = 0.0; Izz = 0.0
  for atom in structure.get_atoms():
    if weighted:
      atom_weight = atomic_weights[atom.element]
    else:
      atom_weight = 1.0 # they are all given the same weight
    x = atom.coords[0]
    y = atom.coords[1]
    z = atom.coords[2]
    Ixx = Ixx + atom_weight*(y*y + z*z)
    Ixy = Ixy - atom_weight*(x*y)
    Ixz = Ixz - atom_weight*(x*z)
    Iyy = Iyy + atom_weight*(x*x + z*z)
    Iyz = Iyz - atom_weight*(y*z)
    Izz = Izz + atom_weight*(x*x + y*y)
  # once the loop is complete, assemble the tensor matrix
  I = numpy.array([[Ixx, Ixy, Ixz],
                   [Ixy, Iyy, Iyz],
                   [Ixz, Iyz, Izz]])
  structure.moveby(com)
  return(I)

def principal_axes(structure, weighted=True):
  '''finds the principal axes of a structure'''
  I = moments_of_inertia(structure,weighted)
  evals, evecs = numpy.linalg.eig(I) # calculated the Inertia tensor
  # sort the eigenvectors by their eigenvalues
  idx = evals.argsort()[::-1]
  evals = evals[idx]
  evecs = evecs[:,idx]
  crs = normalize_vector(numpy.cross(evecs[:,0], evecs[:,1]))
  if not numpy.allclose(crs, evecs[:,2]):
    evecs[:,2] = -evecs[:,2]
  evecs = evecs.T # better to get the transpose
  return evals, evecs


def molecular_radius(structure):
  '''finds the distance of the structure center of mass to the furthest atom'''
  com = center_of_mass(structure)
  largest_radius = 0.0
  for atom in structure.get_atoms(): # for every atom in the structure
    if atom.radius == '0.0':
      atom_radius = radii[atom.element]
    else:
      atom_radius = atom.radius
    radius = numpy.linalg.norm(numpy.array(atom.coords) - numpy.array(com)) + float(atom_radius)
    if radius > largest_radius: largest_radius = radius
  return largest_radius

def regurge(infile,outfile):
  '''reads a pdbfile and attempts to rewrite it back out exactly the same way'''
  structure=parser.get_structure('regurge', infile, preserve_index = False)
  structure.save(outfile, standard=False)

def load_pdb_traj(infilename):
  '''reads a pdb trajectory separated by ENDMDL lines and returns a list of structures'''
  # Warning: This function is currently SLOW! Try to use MDAnalysis
  traj =[]
  starttime = time.time()
  pdbtemp = StringIO() # a file-like object to hold the current pdb file to be opened later by the pdb parser
  infile = open(infilename,'r')
  counter = 0
  for line in infile.xreadlines(): # read every line in the file
    pdbtemp.write(line)
    if line.startswith("ENDMDL"): # then we have ended a frame of the pdb trajectory
      pdbtemp.seek(0) # reset to the beginning of the file
      curstruct = parser.get_structure('traj_frame%d' % counter, pdbtemp, preserve_index = False)
      traj.append(curstruct)
      pdbtemp = StringIO()
    counter += 1
  curstruct = parser.get_structure('traj_frame%d' % counter, pdbtemp, preserve_index = False)
  if curstruct.num_atoms > 0: # this is to help prevent a frame containing nothing from being written
    traj.append(curstruct)
  pdbtemp.close()
  print "time elapsed:", time.time() - starttime
  return traj

def pdb_from_MDAnalysis(MDatomselection):
  '''given an MD atomselection object, this function will return a pdb file object'''
  newstruct = Structure("From MD Analysis") # create a new structure object
  for atom in MDatomselection.atoms: # for every atom in this selection
    newatom = Atom(record='ATOM', index=atom.number, name=atom.name, altloc='', resname=atom.resname, chain='X', resid=atom.resid, icode='', x=atom.pos[0], y=atom.pos[1], z=atom.pos[2], occupancy=0.0, beta=0.0, element=find_element(atom.name), charge=atom.charge)
    newstruct.atoms.append(atom)
  newstruct.num_atoms = len(MDatomselection.atoms)
  return newstruct

'''def pdb_from_MDAnalysis_alt(MDatomselection):
  # TOO SLOW
  MDatomselection.write('/tmp/temp_md.pdb', format="PDB")
  newstruct = parser.get_structure('From MD Analysis', '/tmp/temp_md.pdb')
  return newstruct'''

def test2methods(n,MDatomselection):
  starttime = time.time()
  for i in range(n):
    something = pdb_from_MDAnalysis(MDatomselection)
  endtime = time.time()
  print "method 1 time:", endtime - starttime

  starttime = time.time()
  for i in range(n):
    something = pdb_from_MDAnalysis_alt(MDatomselection)
  endtime = time.time()
  print "method 2 time:", endtime - starttime

def ligmerge(ligand, receptor, remove_water=True, hard_limit=3.0, verbose=True):
  '''given a ligand structure and a receptor structure, will merge the two to create a single structure.
  if remove_water is True, will remove all water molecules clashing with the ligand within the hard_limit'''
  removing_atoms = ["HOH", "H2O", "WAT", "Cl-", "Na+"]
  new_receptor = deepcopy(receptor)
  lig_com = center_of_mass(ligand)
  if verbose: print "lig_com:", lig_com
  lig_rad = molecular_radius(ligand)
  within_lig_proximity = [] # all receptor atoms close to the ligand
  for recatom in range(receptor.num_atoms): # loop thru the receptor atoms
    recatom_coords = numpy.array(receptor.atoms[recatom].coords)
    dist = numpy.linalg.norm(recatom_coords - lig_com)
    if dist < lig_rad + hard_limit: # if the rec atom is within the molecular radius of the ligand center
      within_lig_proximity.append(receptor.atoms[recatom]) # append the atom index
  # now we have all the indeces of any water molecule that could possibly be clashing, find the ones who are actually clashing
  clashing_waters = []
  resids_to_remove = []
  for prox_atom in within_lig_proximity:
    for lig_atom in ligand.get_atoms():
      lig_coords = numpy.array(lig_atom.coords)
      rec_coords = numpy.array(prox_atom.coords)
      #if prox_atom.resid == 5883 and verbose: print "found resid 5883"
      if numpy.linalg.norm(rec_coords - lig_coords) < hard_limit: # then its clashing
        #print "clashing", numpy.linalg.norm(rec_coords - lig_coords), rec_coords, lig_coords
        if prox_atom.resname in removing_atoms: # then mark the waters for removal
          if prox_atom.element == "H": # ...but only if its an oxygen
            pass  # ignore clashing hydrogens
          else: # then its presumably a hydrogen
            resids_to_remove.append(prox_atom.resid) # NOTE: method does not exist yet
        else: # then something else is clashing
          if verbose: print "Alert: non-H2O atom clashing with ligand: id:%d resname:%s resid: %s" % (prox_atom.index, prox_atom.resname, prox_atom.resid)
      else:
        pass
        #print "not clashing", numpy.linalg.norm(rec_coords - lig_coords), rec_coords, lig_coords
  new_receptor.remove_res(resids_to_remove)
  # now create a new structure, appending non-waters first
  new_holo = Structure('holo')
  hit_water_1 = False
  hit_water_2 = False
  counter1 = 0
  counter2 = 0
  oldresid = ''
  # loop through until we hit water or ions
  if new_receptor.num_atoms == 0: return new_holo, 0
  while hit_water_1 == False:
    curresname = new_receptor.atoms[counter1].resname
    if curresname in removing_atoms:
      hit_water_1 = True
      break
    new_holo.atoms.append(deepcopy(new_receptor.atoms[counter1]))
    new_holo.num_atoms += 1
    if new_receptor.atoms[counter1].resid != oldresid:
      new_holo.num_resids += 1
      oldresid = new_receptor.atoms[counter1].resid
    counter1 += 1
    if counter1 >= new_receptor.num_atoms:
      break
  inserted_index = counter1 # the last index of the receptor where the ligand was added
  # we've added all protein atoms from the receptor, now add ligand
  oldresid = ''
  for counter2 in range(ligand.num_atoms):
    new_holo.atoms.append(deepcopy(ligand.atoms[counter2]))
    new_holo.num_resids += 1
    if ligand.atoms[counter2].resid != oldresid:
      new_holo.num_resids += 1
      oldresid = ligand.atoms[counter2].resid
  last_ligand_index = counter2
  # all ligand atoms are added, now add the rest of the water molecules from receptor
  oldresid = ''
  for counter1 in range(counter1, new_receptor.num_atoms):
    new_holo.atoms.append(deepcopy(new_receptor.atoms[counter1]))
    new_holo.num_atoms += 1
    if new_receptor.atoms[counter1].resid != oldresid:
      new_holo.num_resids += 1
      oldresid = new_receptor.atoms[counter1].resid

  # all atoms now added to new structure in proper order
  return new_holo, inserted_index, last_ligand_index

def normalize_vector(array, axis=-1):
  """
  Normalize the vectors of A in the direction of axis. This means that each
  vector will have length 1. The default axis is the last.

  Arguments:

      - array (``numpy.ndarray``) A numpy array.
      - axis (``int``) The axis which will have vectors of lenght 1.
  """
  shape = list(array.shape)
  shape[axis] = 1
  length = numpy.sqrt((array*array).sum(axis))
  out = array / length.reshape(shape)
  return out

class Test_pdb_functions(unittest.TestCase):
  # several test cases to ensure the functions in this module are working properly
  #def aaa(self): # this function runs first, it's like an initialization
  #  print "initializing..."


  def test_main(self):
    #print "WARNING: pdb2.py does not have comprehensive unittests"
    return


  def test_Atom_class(self): # unit test for the Atom class
    # first test __init__()
    testatom = Atom(record="ATOM", index="150", name="CA", altloc='', resname="ALA", chain="X", resid="15", icode='', x='123.456', y='234.567', z='345.678', occupancy="1.00", beta='0.50', element='C', charge='0.30')
    self.assertEqual(testatom.record, "ATOM"); self.assertEqual(testatom.index, 150); self.assertEqual(testatom.name, "CA"); self.assertEqual(testatom.resname, "ALA"); self.assertEqual(testatom.chain, "X")
    self.assertEqual(testatom.resid, "15"); self.assertEqual(testatom.coords, [123.456,234.567,345.678]); self.assertEqual(testatom.occupancy, 1.0); self.assertEqual(testatom.beta, 0.5)
    self.assertEqual(testatom.element, 'C'); self.assertEqual(testatom.charge, 0.3);
    # test get_coords()
    self.assertEqual(testatom.get_coords(), [123.456,234.567,345.678])
    # test to_dict()
    testdict = testatom.to_dict()
    atomdict = {'record':"ATOM", 'index':150, 'name':"CA", 'altloc':'', 'resname':"ALA", 'chain':"X", 'resid':"15", 'icode':'', 'x':123.456, 'y':234.567, 'z':345.678, 'occupancy':1.0, 'beta':0.5, 'element':'C', 'charge':0.30,'radius':0.0}
    self.assertEqual(testatom.to_dict(), atomdict)
    # test write_pdbline()
    # standard
    result = testatom.print_pdbline(standard=True, space_separated_values=False)
    expected_result = "ATOM    150  CA  ALA X  15     123.456 234.567 345.678  1.00  0.50           C  \n"
    self.assertEqual(result, expected_result) # standard mode
    # space separated values
    result = testatom.print_pdbline(standard=False, space_separated_values=True)
    expected_result = "ATOM 150 CA ALA X 15 123.456 234.567 345.678 1.00 0.50 C"
    self.assertEqual(result, expected_result) # space separated mode
    # test set_coords()
    testatom.set_coords([987.654, 876.543, 765.432])
    self.assertEqual(testatom.coords, [987.654, 876.543, 765.432])

  def test_Structure_class(self): # unit test for the Structure class
    # first test __init__()
    empty = Structure('unit test empty')


  def test_loadpdb(self): # this simultaneously tests many other functions in the parser
    self.assertEqual(test_struct1_pdb.num_atoms, len(test_struct1_pdb.atoms))
    self.assertEqual(test_struct1_pdb.num_resids, 3)
    self.assertEqual(test_struct1_pdb.num_atoms, 22)
    self.assertEqual(test_struct2_pdb.num_atoms, len(test_struct2_pdb.atoms))
    self.assertEqual(test_struct2_pdb.num_resids, 8519)
    self.assertEqual(test_struct2_pdb.num_atoms, 26565)
    self.assertEqual(test_struct3_pdb.num_atoms, len(test_struct3_pdb.atoms))
    self.assertEqual(test_struct3_pdb.num_resids, 1544)
    self.assertEqual(test_struct3_pdb.num_atoms, 23004)

  def test_pdb_parse(self):
    test_pdb_line = "ATOM      1  N   MET X   0    -304.463-303.390 111.670  0.00  0.00            "
    test1_list = [['ATOM', '1', 'N', '', 'MET', 'X', '0', '', '-304.463','-303.390','111.670', '0.00', '0.00', '', '']]
    test_pqr_line = "ATOM      1    N MET     0    -304.463-303.390 111.670 -0.3000 1.8000"
    test2_list = [['ATOM', '1', 'N', 'MET', '0', '-304.463','-303.390','111.670', '-0.3000', '1.8000']]
    problem_line =  "ATOM      1  N   VAL     1      -1.552  16.438 -23.987  0.0577 1.8240"
    test3_list = [['ATOM', '1', 'N', 'VAL', '1', '-1.552','16.438','-23.987', '0.0577', '1.8240']]
    pdb_line = parser.conventional_parse(test_pdb_line,pqr=False)
    self.assertEqual(pdb_line, test1_list)
    pqr_line = parser.conventional_parse(test_pqr_line,pqr=True)
    self.assertEqual(pqr_line, test2_list)
    pqr_line = parser.conventional_parse(problem_line,pqr=True)
    self.assertEqual(pqr_line, test3_list)

  def test_pdbparse_pqr(self):
    problem_line = "ATOM      1   N  VAL     1      -1.552  16.438 -23.987  0.0577 1.8240"
    test_list = [['ATOM', '1', 'N', 'VAL', '1', '-1.552','16.438','-23.987', '0.0577', '1.8240']]
    pqr_line = parser.conventional_parse(problem_line,pqr=True)
    self.assertEqual(pqr_line, test_list)


  def test_make_pqr_line(self):
    test_pqr_line = "ATOM      1  N   MET     0    -304.463-303.390 111.670 -0.3000  1.800\n"
    test_line_dict1 = {'index':1, 'name':'N', 'resname':'MET', 'resid':'0', 'x':-304.463, 'y':-303.390, 'z':111.670, 'radius':1.8000, 'charge':-0.3000}
    test_line_dict2 = {'index':'1', 'name':'N', 'resname':'MET', 'resid':'0', 'x':'-304.463', 'y':'-303.390', 'z':'111.670', 'radius':'1.800', 'charge':'-0.3000'}
    result = make_pqr_line(test_line_dict1, chain=False)
    self.assertEqual(test_pqr_line, result)
    result = make_pqr_line(test_line_dict2, chain=False)
    self.assertEqual(test_pqr_line, result)

  def test_make_pqrxml_line(self):
    test_pqr_line = formatline = '''    <atom>
      <atom_name>N</atom_name>
      <atom_number>1</atom_number>
      <x>-304.463000</x>
      <y>-303.390000</y>
      <z>111.670000</z>
      <charge>-0.300000</charge>
      <radius>1.800000</radius>
    </atom>\n'''
    test_line_dict1 = {'index':1, 'name':'N', 'resname':'MET', 'resid':'0', 'x':-304.463, 'y':-303.390, 'z':111.670, 'radius':1.8000, 'charge':-0.3000}
    test_line_dict2 = {'index':'1', 'name':'N', 'resname':'MET', 'resid':'0', 'x':'-304.463000', 'y':'-303.390000', 'z':'111.670000', 'radius':'1.800000', 'charge':'-0.300000'}
    result = make_pqrxml_line(test_line_dict1)
    self.assertEqual(test_pqr_line, result)
    result = make_pqrxml_line(test_line_dict2)
    self.assertEqual(test_pqr_line, result)

  def test_find_element(self): # just a small test to make sure that the function calls without an error
    self.assertEqual(find_element('CA'), 'C') # alpha carbon

  def test_avg(self): # just a small test to make sure that the function calls without an error
    test_list = [20,60,70]
    test_avg = 50
    self.assertEqual(avg(test_list), test_avg)

  def test_get_coords(self): # just a small test to make sure that the function calls without an error
    getcoords(test_struct1_pdb)

  def test_minmax_width(self):
    minmax_list = minmax_width(test_struct1_pdb, water_only=False)
    expected = (5.2510000467300415,7.6479997634887695,3.021000027656555)
    for i in range(len(expected)):
      self.assertAlmostEqual(minmax_list[i], expected[i], places=3)

  def test_center(self):
    center_list = center(test_struct1_pdb)
    expected = (4.1114999651908875, 4.823999881744385, -0.6205000281333923)
    for i in range(len(expected)):
      self.assertAlmostEqual(center_list[i], expected[i], places=3)

  def test_center_of_mass(self):
    center_list = center_of_mass(test_struct1_pdb, weighted = False)
    expected = (4.4929094314575195, 4.853545665740967, -0.22363637387752533) # center of mass
    for i in range(len(expected)):
      self.assertAlmostEqual(center_list[i], expected[i], places=3)

  def test_moments_of_inertia(self): # just a small test to make sure that the function calls without an error
    moments_of_inertia(test_struct1_pdb)

  def test_principal_axes(self): # just a small test to make sure that the function calls without an error
    principal_axes(test_struct1_pdb)

  def test_molecular_radius(self): # just a small test to make sure that the function calls without an error
    molecular_radius(test_struct1_pdb)

  def test_regurge(self): # just a small test to make sure that the function calls without an error
    regurge(test_struct1_pdb_filename,'/tmp/test.pdb')

  def test_load_pdb_traj(self):
    pass # not testing this function

  def test_pdb_from_MDAnalysis(self):
    pass # not testing this function

  def test_ligmerge(self):
    pass # not testing this function

  def test_normalize_vector(self):
    vec = numpy.array([1.0, 2.0, 3.0])
    normed = numpy.array([0.2672612419124244, 0.5345224838248488, 0.8017837257372732])
    self.assertEqual(normalize_vector(vec).all(), normed.all())


if __name__=="__main__":
  print "Now running unit tests for pdb2.py"
  test_struct1_pdb_filename = '../test/adi_dry.pdb' # an alanine dipeptide
  test_struct2_pdb_filename = '../test/tropc_wet.pdb' # troponin C solvated in H2O
  test_struct3_pdb_filename = '../test/cal-2hty-tetra.pdb'
  test_struct1_pqr_filename = '../test/tami.pqr'
  test_struct2_pqr_filename = '../test/tropc_dry.pqr'
  test_struct3_pqr_filename = '../test/cal-2hty-tetra.pqr'
  test_struct1_pqrxml_filename = '../test/tami.pqrxml'
  test_struct1_pdb = loadpdb(test_struct1_pdb_filename)
  test_struct2_pdb = loadpdb(test_struct2_pdb_filename)
  test_struct3_pdb = loadpdb(test_struct3_pdb_filename)
  test_struct1_pqr = loadpqr(test_struct1_pqr_filename)
  test_struct2_pqr = loadpqr(test_struct2_pqr_filename)
  test_struct3_pqr = loadpqr(test_struct3_pqr_filename)
  unittest.main() # then run unit tests
